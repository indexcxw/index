### 学习笔记

## 1.APK生成

注意生成APK的时候，RES文件下的导入文件名称必须得在a-z 0-9不能大写，否则就会报错。

## 2.Android操作数据库原理阐述

  既然是要操作数据库，那么首先我们得选一款数据库，因为这个世界上，现存数据库种类很多。能随口就说上来的有，比如：Oracle、MySQL、SQLSever、KingBase，这四个是我随口就能说出来的，其他的像NoSQL、DB2......这些都是我得想一会才能说出来的，那么Android选的这款数据库，是我之前听都没听说过的一款，SQLite。发音是：[sk'laɪt] ，塞克赖特。当然，不是说Android数据库只能是SQLite，其它的也有办法实现，只不过，AndroidSDK中自带的是SQLite。

​    铺垫到此为止，下面写正文。

 

​    Android 提供的 SQLiteOpenHelper.java 是一个抽象类。那么我们要使用它，必须自己写一个类来继承它，为了达到见名知意的目的习惯上，我们创建的都是DatabaseHelper.java或者简写DBHelper.java，这个无所谓，你创建成1234.java都行。

​    这一行规定死了，只能是这样的：

```java
public class DatabaseHelper extends SQLiteOpenHelper{
```

​    接下来需要写一个带全部参数的DatabaseHelper类的构造函数，以后生成数据库对象的时候要用到：

```java
//带全部参数的构造函数，此构造函数必不可少



    public DatabaseHelper(Context context, String name, CursorFactory factory, int version) {



        super(context, name, factory, version);



    }
```

​    构造函数完事之后，写继承的抽象类SQLiteOpenHelper中的两个抽象方法：

```java
    @Override



    public void onCreate(SQLiteDatabase db) {



        //创建数据库sql语句 并 执行



        String sql = "create table user(name varchar(20))";



        db.execSQL(sql);



    }



    @Override



    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {



 



    }
```

​    上面的代码有两个问题，问题1.为什么onUpgrade()方法是空的？答案：因为它是抽象方法，必须被继承，但我为了达到极简的目的又没有用到它，一方面必须重写，一方面没有用到，所以就是一个空方法在这摆着样子了。问题2.为什么只重写这两个方法，其他的方法呢？答案：因为SQLiteOpenHelper.java中，只有这两个方法是抽象方法，你不信？我给你看看源码。（在AndroidStudio中我们按住Ctrl同时鼠标单击SQLiteOpenHelper就能进入它的源码中，在源码界面按住Ctrl+F 就能调出搜索框，输入abstract，点击向下箭头↓ 查找匹配项）

![img](https://img-blog.csdn.net/20180627204401212?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pZG5pZ2h0X3RpbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/20180627205037810?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pZG5pZ2h0X3RpbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)![img](https://img-blog.csdn.net/20180627205047426?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pZG5pZ2h0X3RpbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​    到此为止，我们自己创建的DatabaseHelper.java所有代码就已经写完了。

​    接下来看MainActivity.java文件中的代码，其中只有两部分代码。

![img](https://img-blog.csdn.net/20180627205700977?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21pZG5pZ2h0X3RpbWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

第一句代码中，创建Activity时会自动生成

```html
public class MainActivity extends AppCompatActivity
```

在后面加上 下面这句，就能把onClick()方法写到onCreate()方法之外了

```html
implements OnClickListener
```

MainActivity.java中第一部分代码：   

创建Activity时的代码即onCreate()方法，要我们自己写的就两件事：

1.根据Layout按钮id生成Java按钮对象

 就像这样：Button insert = (Button)findViewById(R.id.insert);

2.为所有Java按钮对象设置监听器     

  就像这样：insert.setOnClickListener(this);

 

MainActivity.java中第二部分代码：      

响应屏幕点击时的代码即onClick()方法，我们需要写三件事：

1.生成EditText对象，用来获取文本输入框中用户输入的内容

  就像这样：EditText insert_edittext = (EditText)findViewById(R.id.insert_edittext);

2.创建数据库，这里我们给数据库起名为“test_db”，数据库版本号为1，代码如下：

```java
        //依靠DatabaseHelper带全部参数的构造函数创建数据库



        DatabaseHelper dbHelper = new DatabaseHelper(MainActivity.this, "test_db",null,1);



        SQLiteDatabase db = dbHelper.getWritableDatabase();
```

3.响应增、删、改、查四个按钮点击时触发的操作

①增：插入数据，首先需要new一个ContentValues，内容值对象。

​    所谓的内容值，就是一个K,V 键值对，K指明字段名称即列名称，V指明字段值，即单元格内容。然后将这个键值对放到ContentValues的对象values里面，再把携带着键值对的对象values插入user表中，代码如下：

```java
            //插入数据按钮



            case R.id.insert:



                //创建存放数据的ContentValues对象



                ContentValues values = new ContentValues();



                values.put("name",insert_data);



                //数据库执行插入命令



                db.insert("user", null, values);



                break;



 
```

②删：删除数据，这里不需要生成ContentValues对象，直接从表user中delete符合要求的内容即可，代码如下：

```java
            //删除数据按钮



            case R.id.delete:



                db.delete("user", "name=?", new String[]{delete_data});



                break;
```

③改：更新数据，这里和插入数据类似，需要new一个ContentValues对象，然后放入数据，执行update，代码如下：

```java
            //更新数据按钮



            case R.id.update:



                ContentValues values2 = new ContentValues();



                values2.put("name", update_after_data);



                db.update("user", values2, "name = ?", new String[]{update_before_data});



                break;
```

④查：查询全部数据，这里使用了Cursor游标进行查询，游历数据同时，把数据用换行符\n连接起来,再把所有数据展示到文本显示框内，代码如下：

```java
            //查询全部按钮



            case R.id.query:



                //创建游标对象



                Cursor cursor = db.query("user", new String[]{"name"}, null, null, null, null, null);



                //利用游标遍历所有数据对象



                //为了显示全部，把所有对象连接起来，放到TextView中



                String textview_data = "";



                while(cursor.moveToNext()){



                    String name = cursor.getString(cursor.getColumnIndex("name"));



                    textview_data = textview_data + "\n" + name;



                }



                textview.setText(textview_data);



                // 关闭游标，释放资源



                cursor.close();



                break;
```

 ## 3.Context

刚刚学android或者js等，都会看见这个频繁的字眼——Context。
意为”上下文“。

本文主要记述，Context到底是什么、如何理解Context、一个APP可以有几个Context、Context能干啥、Context的作用域、获取Context、全局获取Context技巧。

------

## 思考：

Java:万物皆对象。Flutter:万物皆组件。
俗语：”没对象吗？自己new一个啊~“
既然大多数情况可以new一个实例，那么，我们在android中的Activity实例怎么获取呢？Activity.instance可以获取activity。既然Activity也大致归属于一个类，那么可不可以用 **Activity activity=new Activity();** 呢？安卓不像Java程序一样，随便创建一个类，写个main(）方法就能运行，***Android应用模型是基于组件的应用设计模式，组件的运行要有一个完整的Android工程环境。***在这个环境下，Activity、Service等系统组件才能正常工作，而这些组件不能采用普通的java对象创建方式，new一下是不能创建实例的，而是要有**它们各自的上下文环境，也就是Context.**
所以说，**Context是维持android各组件能够正常工作的一个核心功能类。**

------

## what 's Context:

(本图为沙拉查词给出的中文翻译)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190307204052358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTY5MjI2,size_16,color_FFFFFF,t_70)
有点晦涩难懂。但在程序中，我们可理解**为当前对象在程序中所处的一个环境，一个与系统交互的过程。** 比如QQ和你们自己的女朋友聊天时（没有grilfriend的可自己跳过举例），此时的context是指的聊天界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。
所以，一个Activity就是一个Context（getActivity()==getContext），一个Service也是一个Context。Android把场景抽象为Context类，用户和操作系统的每一次交互都是一个场景，比如：打电话、发短信等，都有activity，还有一些我们肉眼看不见的后台服务。一个应用程序可以认为是一个工作环境，用户在这个环境中切换到不同的场景，这就像服务员，客户可能是外卖小哥、也可能是农民工等，这些就是不同的场景，而服务员就是一个应用程序。

------

## How to understand the ‘Context’:

Context理解为”上下文“/”场景“，可能还是很抽象。那么我们可以做一个比喻：
一个APP是仙剑奇侠传3电视剧，Activity、Service、BroadcastReceiver、ContentProvider这四大组件就是电视剧的主角。它们是导演(**系统**)一开始就确定好试镜成功的人。换言之， 不是我们每个人都能被导演认可的。有了演员，就要有镜头啊，**这个镜头便是(Context)**。通过镜头，我们才能看见帅气 的胡歌。演员们都是在镜头(Context环境)下表演的。那么Button这些组件子类型就是配角，它们没有那么重要，随便一个组件都能参与演出（即随便new 一个实例），但是它们也需要参与镜头，不然一部戏只有主角多没意思，魔尊重楼还是要的，魔尊也要露面(工作在Context环境下)，所以可以用代码new Button()；或者xml布局定义一个button。

打开AndroidStudio，输入Context，然后ctrl+鼠标左键追朔其源码(看源码一般都先看注释便于理解)：**import android.content.Context;**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190307220433372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5OTY5MjI2,size_16,color_FFFFFF,t_70)
看注释，TMD，是English，那么笔者这里就用小学生英语水平来翻译一哈哈：
Context提供了关于应用环境全局信息的接口。它是一个abstract类，它的执行被Android系统提供，允许获取以应用为特征的资源和类型，是一个统领一些资源APP环境变量等的上下文。通过它可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接收intent等）。abstract会有它的实现类。在源码中，我们可以通过AndroidStudio去查看它的子类，得到以下关系：
它有2个具体实现子类：ContextImpl、ContextWrapper。

- 其中，ContextWrapper类，只是一个包装类，其构造函数中必须包含一个Context引用，同时它提供了attachBaseContext(）用于给ContextWrapper对象中指定真正的Context对象，调用它的方法都会被转向其所包含的真正的Context对象。
- ContextThemeWrapper类其内部包含了与主题相关的接口。主题就是清单文件中android:theme为Application或Activity元素指定的主题。（Activity才需要主题，Serviceu不需要，因为服务是没有界面的后台场景，所以服务直接继承ContextWrapper。Application同理。）而Contextlmpl类则是真正实现了Context中的所有函数，应用程序中所调用的各种Context类的方法，其实现均来自这个类。
- **换言之：Context的2个实现子类分工的，其中ContextImpl是Context的具体是实现类，而ContextWrapper则是Context的包装类。Activity、Application、Service都继承自ContextWrapper(Activity继承自ContextWrapper的子类ContextThemeWrapper)，但它们的初始化过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。**

------

## How much has Context in a App:

关键在于对Context的理解。从上面提到的实现子类可以看出，在APP中，Context的具体实现子类是Acitivity、Service、Applicaiton。所以Context’s number=Activity’s number + Service’s number+1(1个APP只有一个Application)。为啥不是4大组件，上面不是说四大组件也是主角吗？看看BroadcastReceiver和ContentProvider的源码可以知道它们并不是Context的子类，它们持有的Context都是其他地方传递过去的(比如我们发送广播intent中的context就是外部传递过来的)，所以不计数它们。

------

## Context’s method:

Context哪里会用到它。刚开始了解Android的时候不知道它是个啥玩意儿，但是久了发现有些地方就不得不传这个参数。
比如Toast、启动Activity、启动Service、发送广播、操作数据库等等都需要传Context参数，具体例子就不说了。详细可以看后文将提到的如何获取它。

------

## Context’s 作用域:

不是随便获取一个Context实例就可以的，它的使用有一些规则和限制。因为Context的具体实例是由ContextImpl类去实现的，因此，Activity、Service、Application3种类型的Context都是等价的。但是，需要注意的是，，有些场景，比如启动Activity、弹出Dialog等。为了安全，Android不允许Activity或者Dialog凭空出现，一个Activity的启动肯定是由另一个Activity负责的，也就是以此形成的返回栈（具体可以看看任主席的《Android开发艺术探索》）而Dialog则必须是在一个Activity上弹出（系统Alert类型的Dialog除外），这种情况下， 我们只能用Activity类型的Context，否则报错。

| Context作用域               | Application | Activity | Service |
| --------------------------- | ----------- | -------- | ------- |
| Show a Dialog               | No          | Yes      | No      |
| Start an Activity           | 不推荐      | Yes      | 不推荐  |
| Layout Inflation            | 不推荐      | Yes      | 不推荐  |
| Start a Service             | Yes         | Yes      | Yes     |
| Send a Broadcast            | Yes         | Yes      | Yes     |
| Register Broadcast Receiver | Yes         | Yes      | Yes     |
| Load Resource Values        | Yes         | Yes      | Yes     |

Activity继承自ContextThemeWrapper，而Application和Service继承ContextWrapper，所以ContextThemeWrapper在ContextWrapper的基础上作了一些操作，使得Activity更加厉害。
**关于表格中提到的Application和Service不推荐的2种情况：**

1. 如果用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错：androud,util.AndroidRuntimeException:Calling startActivity from outside of an Activity context require the FLAG_ACTIVITY_NEW_TASK flag。Is this really what you want?
   翻译一下，并了解这个FLAG的都知道，此时的非Activity类型的Context并没有所谓的返回栈，因此带启动的Activity就找不到栈。它还给我们明确之处了FLAG的解决办法，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以Single Task模式启动的。所以这种用Application Context启动Activity的方式不推荐，Service同理。
2. 在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果自定义了某些样式可能不会被使用，所以也不推荐。

**注：和UI相关的，都应该使用Activity Context来处理。其他的一些操作，Service、Activity、Application等实例都是可以的。同时要注意Context的引用持有，防止内存泄漏。可在被销毁的时候，置Context为null。**

## How to get the ‘Context’:

常用4种方法获取Context对象：

1. View.getContext()：返回当前View对象的Context对象。通常是当前正在展示的Activity对象。
2. Activity,getApplicationContext()[后文会详细介绍这个方法]：获取当前Activity所在应用进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。
3. ContextWrapper.getBaseContext()：用来获取一个ContextWrapper进行装饰之前的Context。实际开发很少用，也不建议使用。
4. Activity.this：返回当前Activity的实例，如果的UI控件需要使用Activity作为Context对象，但默认的Toast实际上使用的ApplicationContext也可以。
   **实现View.OnClick监听方法中，写Toast，不要用this,因为this,在onClick(View view)指的是view对象而不是Activity实例，所以在这个方法中，应该使用”当前的Activity名.this“，这是入门者比较容易混淆的地方。**

- getApplication()和getApplicationContext()：
  获取当前Application对象用getApplicationContext.但是getApplication又是什么。
  我们可以自己写代码打印一下：

```
Application app=(Application)getApplication();
Log.e(TAG,"getApplication is "+app);
Context context=getApplicationContext();
Log.e(TAG,"getApplicationContext is "+ context);
1234
```

运行后看logcat，效果图就不贴了（电脑卡）。从打印结果可以看出它们**2个的内存地址是相同的，即它们是同一个对象。** 因为Application本来就是一个Context，那么这里获取的getApplicationContext()自然也是Application本身的实例了。那这2个相同方法存在的意义是啥？（双胞胎？）实际上这**2个方法在作用域上有比较大的区别。** getApplication（）一看就知道是用来获取Application实例的(道理可以联想getActivity())。但**getApplication()只有在Activity和Service中才能调用的到。** 对于**比如BroadcastReceiver等中也想要获取Application实例，这时就需要getApplicationContext()方法。**

```
//继承BroadcastReceiver并重写onReceive()方法
@Override
public void onReceive(Context context.Intent intent){
	Application app=(Application)context.getApplicationContext();
}
12345
```

------

## 内存泄漏之Context：

我们经常会遇到内存泄漏，比如Activity销毁了，但是Context还持有该Activity的引用，造成了内存泄漏。(经常遇到)

2种典型的错误引用方式：

1. 错误的单例模式：

```
public class Singleton{
	private static Singleton instancel
	private Context context;
	private Singleton(Context context){
		this.context=context;
	}
	public static Singleton getInstance(Context context){
		if(instance == null ){
			instance=new Singleton(context);
		}
		return instance;
	}
}
12345678910111213
```

熟悉单例模式的都知道，这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象（单例直到APP退出后台才销毁），其中也包含了Activity。比如Activity A去getInstance()得到instance对象，传入this,常驻内存的Singleton保存了我们传入的A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。比如典型的数据库操作，存储数据，需要重复的去索取数据，用单例保持数据和拿到Activity持有context引用，因为单例可以看作是上帝，它帮我们保存数据。所以即使Activity被finish掉，还有它的引用在Singleton中。

1. View持有Activity引用：

```
public class MainActivity extend Activity{
	private static Drawable mDrawable;	
	@Override
	protected void onCreate(Bundle saveInstanceState){
		super.onCreate();
		setContentView(R.layout.activity_main);
		ImageView imageview=new ImageView(this);//通过代码动态的创建组件，而不是传统的xml配置组件，这里的ImageView持有当前Activity的引用。
		mDrawable=getResources().getDrawable(R.drawable.ic_launcher);
		imageview.setImageDrawable(mDrawable);
	}
}
1234567891011
```

上述代码中，有一个static的Drawable对象。当ImageView设置这个Drawable的时候，ImageView保存了这个mDrawable的引用，而ImageView初始化的时候又传入了this,此处的this是指MainActivity的context。因为被static修饰的mDrawable是常驻内存的(比类还要早加载)。MainActivity是它的间接引用了，当MainActivity被销毁的时候，也不能被GC掉，就造成了内存泄漏。

------

## How to get the context in the whole :

大量的地方都需要使用Context，我们常常会因为不知道怎么得到这个Context而苦恼。那么，**全局获取Context**无疑是最好的解决方案。
很多时候，我们也不是经常为得不到Context而发愁，毕竟我们很多的操作都是在活动中进行的，而活动本身就是一个Context对象。但APP架构复杂后，很多逻辑代码都脱离了Activity类，此时又需要使用Context，所以我们需要采取全局获取Context的方法。
举例， 我们平常经常会写网络工具类，比如下面的这些代码：

```java
public calss HttpUtil{
	public static void sendHttpRequest(final String address,final HttpCallbackListener listener){
		new Thread(new Runnable()){
		@Override 
		public void run(){
		HttpURLConnection connection=null;
		try{
			URL url =new URL(address);
			connection=(HttpURLConnection)url.openConnection();
			connection.setRequestMethod("GET");
			connection.setConnectTimeout(8000);
			connection.setReadTimeout(8000);
			connection.setDoInput(true);
			connection.setDoOutput(true);
			InputStream in =connection.getInputStream();
			BufferedReader reader=new BufferedReader(new InputStreamReader(in));
			StringBuilder response=new StringBuilder();
			String line;
			while((line=reader.readLine())!=nulll){
				response.append(line);
			}
			if(listener!=null){
				//回调onFinish()
				listener.onFinish(response.toString);
			}
		}catch(Execption e){
			if(listener!=null){
				//回调onError()
				listener.onError(e);
			}
		}finally{
			if(connection!=null){
				connection.disconnect();
			}
		}
		}}.start();
	}
}
1234567891011121314151617181920212223242526272829303132333435363738
```

上述代码中使用sendHttpRequest()方法来发送HTTP请求显然没问题。并且还可以在回调方法中处理服务器返回的数据。但是这个方法还可以被优化。当检测不到网络存在的时候就给用户一个Toast，并不再执行后面的代码。问题来了，Toast需要一个Context参数，但是在本来没有可以传递的Context对象。。。
一般思路：在方法中添加一个COntext参数：

```
	public static void sendHttpRequest(final String address,final HttpCallbackListener listener，final Context context){
	if(!isNetWorkAvailable()){
		Toast.makeText(context,……);
		……
	}
	……
123456
```

看似可以，但是有点**甩锅**。我们将获取Context的任务转移到了sendHttpRequest()方法的调用方。至于调用方能不能得到COntext对象就不是我们要考虑的问题了。

甩锅不一定是通用的解决方案。于是这里介绍哈如何**获取全局Context的步骤：**,通过它在项目的任何地方都能轻松的获取到Context。：

- Android提供了一个Application类，每当APP启动的时候，系统就会自动将这个类进行初始化。我们可以定制一个自己的Application类，以便管理程序内一些全局的状态信息，比如说全局Context。
- 定制一个自己的Application并不复杂，首先， 需要创建一个MyApplication类继承自系统的Application:

```
public calss MyApplication extends Application{
	private static Context context;
	@Overrride
	public void onCreate(){
		context=getApplicationContext();
	}
	public static Context getContext(){
		return context;
	}
}
12345678910
```

代码很简单，容易理解。重写了父类的onCreate()方法，并通过调用getApplicationContext()方法得到一个应用程序级别的Context，然后又提供了一个静态的getContext()方法，在这里将刚才获取到的COntext进行返回。

- 接下来，我们需要告诉系统，当程序启动的时候应该初始化MyApplication类，而不是系统默认的Application类。这一步需要在清单文件里面实现，找到清单文件的<application>标签下进行指定就可以了：

```
<manifest ……
……>
<application 
		android :name="com.example.myContext.MyApplication" //这里输入.MyApplication也可以，或者输入MyApplication根据AS提示自动补全包名
					..>
</application>
123456
```

**注意：这里一定要加上完整的包名，不然系统将无法找到这个类。**

- 以上就是实现了一种全局获取Context的机制，在这个项目的任何地方使用Context，只需要调用MyApplication.getContext()就可以了。

**关于自定义Application和LitePal配置冲突的问题：**
自定义需要在清单文件写出android.name="……"。而为了让LitePal可以正常工作，也需要在清单文件下，配置：

```
android:name="org.litepal.LitePalApplication"
1
```

道理也是一样的，这样配置后，LitePal就能在内部自动获取到Context了。
问题：当都已经配置过自定义的Application怎么办？岂不是和LitePalApplication冲突了？
解答：**任何一个项目都只能配置一个Application.** 对于这种情况，LitePalApplication给出了很简单的解决方案，在自定义的Application中去调用LitePal的初始化方法就可以了：

```
public calss MyApplication extends Application{
	private static Context context;
	@Overrride
	public void onCreate(){
		context=getApplicationContext();
		LitePalApplication.initialize(context);
	}
	public static Context getContext(){
		return context;
	}
}
1234567891011
```

这种写法就相当于我们把全局Context对象通过参数传递给了LitePal，效果和在清单文件配置LitePalApplication是一样的。

------

**总结，如何在程序中正确的使用Context:**
一般Context造成的内存泄漏，几乎都是当Context销毁的时候，因为被引用导致销毁失败。而Application的Context对象可以简单的理解为伴随着进程存在的（它的生命周期也很长，毕竟APP加载的时候先加载Application,我们可以自定义Application然后继承系统的Application）。
正确使用：

1. 当Applicatin的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context;
2. 不要让生命周期长于Activity的对象持有Activity的引用。
3. 尽量不要在Activity中使用非静态内部类。非静态内部类会隐式持有外部类实例的引用。如果使用静态内部类，将外部实例引用作为弱引用持有。

## 获取全局context的另一种思路：

ActivityThread是主进程的入口，它的currentApplication返回值是application.

```java
import android.app.Application;

import java.lang.reflect.InvocationTargetException;

/**
 * 这种方式获取全局的Application 是一种拓展思路。
 * <p>
 * 对于组件化项目,不可能把项目实际的Application下沉到Base,而且各个module也不需要知道Application真实名字
 * <p>
 * 这种一次反射就能获取全局Application对象的方式相比于在Application#OnCreate保存一份的方式显示更加通用了
 */
public class AppGlobals {
    private static Application sApplication;

    public static Application getApplication() {
        if (sApplication == null) {
            try {
                sApplication = (Application) Class.forName("android.app.ActivityThread")
                        .getMethod("currentApplication")
                        .invoke(null, (Object[]) null);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            } catch (NoSuchMethodException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
        return sApplication;
    }
}
```

## 4.关于Drawble插入图片

  当我们在android的drawable文件下加入图片的，常会因为图片命名不规范而引发一系列问题



1. 当命名后，如果命名错误，根据系统信息提示Invalid file name: must contain only [a-z0-9_.]

可知，命名可以由小写字母和数字和下划线和‘.’组成，且由小写字母作为开头，即不能由下划线或数字开头



2.default和continue等是Java的特殊保留符号，会被系统翻译成Java代码,当图片用此命名时，会出现

Invalid symbol : ‘default’等错误



3.当直接从外部拖拽图片（命名不规范的图片）进来时，系统不会像普通命名时会弹框提示命名错误，

此时android项目也不会报错，但是会出现R.id.XXX等识别不出来的问题，原因是R文件没有生成相应id



4.还有一点也是最让人头痛的一点，当出现第3.的情况时，也会出现导致后续加入的其它控件的id识别不出来的问题，所以当出现控件id识别不了时，可以检查一下drawable文件里的图片命名

1.树：是n(n≥0)个结点的有限集。(1)有且仅有一个特定的称为根（root）的结点;（2）当n>1时，其余的结点分为m(m≥0)个互不相交的有限集合T1,T2，…，Tm。每个集合本身又是棵树，被称作这个根的子树 。

2.二叉树：是n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成。

**二叉树的性质，存储结构。**

性质1: 在二叉树的第i层上至多有2^(i-1)个结点（i>0）。

性质2: 深度为k的二叉树至多有2^k-1个结点（k>0）。

性质3: 对于任何一棵二叉树，如果其终端结点数为n0,度为2的结点数有n2个，则叶子数n0=n2＋1

性质4: 具有n个结点的完全二叉树的深度必为 [log2n]+1

性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）。

**二叉树的存储结构：**

1).顺序存储结构

按二叉树的结点“自上而下、从左至右”编号，用一组连续的存储单元存储。

若是完全/满二叉树则可以做到唯一复原。

不是完全二叉树：一律转为完全二叉树！

方法很简单，将各层空缺处统统补上“虚结点”，其内容为空。

缺点：①浪费空间；②插入、删除不便 

2).链式存储结构

用二叉链表即可方便表示。一般从根结点开始存储。

| lchild | data | rchild |
| ------ | ---- | ------ |
|        |      |        |

优点：①不浪费空间；②插入、删除方便

3.**二叉树的遍历。**

指按照某种次序访问二叉树的所有结点，并且每个结点仅访问一次，得到一个线性序列。

遍历规则:二叉树由根、左子树、右子树构成，定义为D、 L、R

若限定先左后右，则有三种实现方案：

 DLR        LDR          LRD

先序遍历      中序遍历     后序遍历

4.线索二叉树

1）线索二叉树可以加快查找前驱与后继结点，实质就是将二叉链表中的空指针改为指向前驱或后继的线索，线索化就是在遍历中修改空指针。

通常规定：对某一结点，若无左子树，将lchild指向前驱结点；若无右子树，将rchild指向后继结点。

还需要设置左右两个tag，用来标记当前结点是否有子树。

若ltag==1,lchild指向结点前驱；若rtag==1，rchild指向结点后继。

2）线索二叉树的存储结构如下：

typedef struct ThreadNode{

ElemType data;

struct ThreadNode *lchild, *rchild;

int ltag, rtag;

}ThreadNode, *ThreadTree;

![img](https://img-blog.csdn.net/20180730182933554?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

5.树和森林

1）树有三种常用存储方式：

①双亲表示法   ②孩子表示法  ③孩子—兄弟表示法

2）森林、树、二叉树的转换

(1)将树转换为二叉树

树中每个结点最多只有一个最左边的孩子(长子)和一个右邻的兄弟。按照这种关系很自然地就能将树转换成相应的二叉树：a.在所有兄弟结点之间加一连线

b.对每个结点，除了保留与其长子的连线外，去掉该结点与其它孩子的连线。

![img](https://img-blog.csdn.net/20180730183003319?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

(2)将一个森林转换为二叉树：

具体方法是：a.将森林中的每棵树变为二叉树；

b.因为转换所得的二叉树的根结点的右子树均为空，故可将各二叉树的根结点视为兄弟从左至右连在一起，就形成了一棵二叉树。

![img](https://img-blog.csdn.net/20180730183037930?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

(3)二叉树转换为树

是树转换为二叉树的逆过程。

a.加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。

b.去线。删除原二叉树中所有结点与其右孩子结点的连线。

![img](https://img-blog.csdn.net/20180730183058361?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 

(4)二叉树转换为森林：

假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。

a.从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除。直到所有这些根节点与右孩子的连线都删除为止。

b.将每棵分离后的二叉树转换为树。

![img](https://img-blog.csdn.net/20180730183143755?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

6.树和森林的遍历

- 树的遍历

① 先根遍历：访问根结点；依次先根遍历根结点的每棵子树。

② 后根遍历：依次后根遍历根结点的每棵子树；访问根结点。

 

- 森林的遍历

① 先序遍历

若森林为空，返回；

访问森林中第一棵树的根结点；

先根遍历第一棵树的根结点的子树森林；

先根遍历除去第一棵树之后剩余的树构成的森林。

② 中序遍历

若森林为空，返回；

中根遍历森林中第一棵树的根结点的子树森林；

访问第一棵树的根结点；

中根遍历除去第一棵树之后剩余的树构成的森林。

 

7.哈夫曼树及其应用

Huffman树：最优二叉树（带权路径长度最短的树）

Huffman编码：不等长编码。

树的带权路径长度：![img](https://img-blog.csdn.net/20180730183212713?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)(树中所有叶子结点的带权路径长度之和)

构造Huffman树的基本思想：权值大的结点用短路径，权值小的结点用长路径。

构造Huffman树的步骤（即Huffman算法）：

(1) 由给定的 n 个权值{ w1, w2, …, wn }构成n棵二叉树的集合F = { T1, T2, …, Tn } （即森林） ，其中每棵二叉树 Ti 中只有一个带权为 wi 的根结点，其左右子树均空。

(2) 在F 中选取两棵根结点权值最小的树 做为左右子树构造一棵新的二叉树，且让新二叉树根结点的权值等于其左右子树的根结点权值之和。

(3) 在F 中删去这两棵树，同时将新得到的二叉树加入 F中。

(4) 重复(2) 和(3) , 直到 F 只含一棵树为止。这棵树便是Huffman树。

具体操作步骤：

![img](https://img-blog.csdn.net/20180730183236944?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/20180730183249451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

应用：用于通信编码

　　在通信及数据传输中多采用二进制编码。为了使电文尽可能的缩短，可以对电文中每个字符出现的次数进行统计。设法让出现次数多的字符的二进制码短些，而让那些很少出现的字符的二进制码长一些。假设有一段电文，其中用到 4 个不同字符Ａ，Ｃ，Ｓ，Ｔ，它们在电文中出现的次数分别为 7 ， 2 ， 4 ， 5 。把 7 ， 2 ， 4 ， 5 当做 4 个叶子的权值构造哈夫曼树如图(a) 所示。在树中令所有左分支取编码为 0 ，令所有右分支取编码为1。将从根结点起到某个叶子结点路径上的各左、右分支的编码顺序排列，就得这个叶子结点所代表的字符的二进制编码，如图(b) 所示。这些编码拼成的电文不会混淆，因为每个字符的编码均不是其他编码的前缀，这种编码称做前缀编码。

 ![img](https://img-blog.csdn.net/20180730183344350?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 5. 数据结构——图

1.**图的定义，概念、术语及基本操作(**https://blog.csdn.net/eyishion/article/details/53234255**)**

**1）图的定义**

图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成;

通常表示为:G(V,E),G表示一个图，V是图G中顶点的集合，E是图G中边的集合；

注意：在图中数据元素称之为顶点(Vertex),而且顶点集合有穷非空；在图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示。

**2）图的分类**

- 按照有无方向，分为**无向图**和**有向图**；

**无向图：**如果图中任意两个顶点之间的边都是无向边，则称该图为无向图。

无向边：若顶点M到顶点N的边没有方向，称这条边为无向边，用无序偶对(M,N)或(N,M)表示。

无向图是有**边**和**顶点**构成。如下图所示就是一个无向图G1：

![img](https://img-blog.csdn.net/20180730183453308?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

无向图G1= (V1,{E1}),其中顶点集合 V1={A,B,C,D};边集合E1={(A,B),(B,C),(C,D),(D,A)}

有向图：如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。

有向边：若顶点M到顶点N的边有方向，称这条边为有向边，也称为弧，用偶序对 < M, N >表示；M表示弧尾，N表示弧头

有向图是有**弧**和**顶点**构成，如下图所示是一个有向图G2：

![img](https://img-blog.csdn.net/20180730183453335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

有向图G2=(V2，{E2}),其中顶点集合 V2={A,B,C,D};弧集合E2={< A,D>,< B,A>,< C,A>,< B,C>}

对于弧< A,D>来说， A是弧尾，D是弧头

注意：无向边用 小括号 “()”表示，有向边用“<>”表示。

**无向完全图**：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。

含有n个顶点的无向完全图有n * (n-1)/2条边。下面是一个无向完全图

![img](https://img-blog.csdn.net/20180730183453387?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

4个顶点，6条无向边，每个顶点对应3条边 ，一共4个顶点 总共 4*3，每个顶点对应的边都重复计算了一次，所以整体要除以2。

对于n各 顶点和e条边的无向图满足：0<=e <= n(n-1)/2

**有向完全图：**在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。

含有n个顶点的无向完全图有n * (n-1)条边。下面是一个有向完全图

![img](https://img-blog.csdn.net/20180730183453471?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

4个顶点，12条弧，一共4个顶点 总共 4*3。

2，按照弧或边的多少，分为**稀疏图**和**稠密图**；

若边或弧的个数e<=NlogN(N是顶点的个数)，称为系数图，否则称为稠密图；

3，按照边或弧是否带权，其中带权的图统称为**网**

有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权。

有向网中弧带权的图叫做有向网；

无向网中边带权的图叫做无向网；

比如下图就是一个无向图

![img](https://img-blog.csdn.net/20180730183453514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 

**图的顶点和边间关系**

***邻接点 度 入度 出度***

对于无向图，假若顶点v和顶点w之间存在一条边，则称顶点v和顶点w互为**邻接点**，边(v,w)和顶点v和w相关联。

顶点v的**度**是和v相关联的边的数目，记为TD(v);

![img](https://img-blog.csdn.net/20180730183453523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

上面这个无向图G1，A和B互为邻接点，A和D互为邻接点，B和C互为邻接点，C和D互为邻接点;

A的度是2,B的度是2,C的度是2,D的度是2;所有顶点度的和为8，而边的数目是4；

**图中边的数目e = 各个顶点度数和的一半。**

对于有向图来说，与某个顶点相关联的弧的数目称为度(TD)；以某个顶点v为弧尾的弧的数目定义为顶点v的出度(OD)；以顶点v为弧头的弧的数目定义为顶点的入度(ID)

度(TD) = 出度(OD) + 入度(ID);

![img](https://img-blog.csdn.net/20180730183453727?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

比如上面有向图，

A的度为3 ，A的入度 2，A的出度是1

B的度为2 ，B的入度 0，B的出度是2

C的度为2 ，C的入度 1，C的出度是1

D的度为1 ，D的入度 1，D的出度是0

所有顶点的入度和是4，出度和也是4，而这个图有4个弧

所以 有向图的弧 e = 所有顶点入度的和 = 所有顶点出度的和

***路径 路径长度 简单路径 回路 (环) 简单回路(简单环)***

设图G=(V，{E})中的一个顶点序列{u=Fi0,Fi1,Fi2,….Fim=w}中，(Fi,j-1,Fi,j)∈E 1 ≤j ≤m,则称从顶点u到顶点w之间存在一条**路径**，路径上边或弧的数目称作**路径长度**，

若路径中的顶点不重复出现的路径称为**简单路径**

若路径中第一个顶点到最后一个顶点相同的路径称为**回路或环**

若路径中第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为**简单回路或简单环**

比如下图 ：

![img](https://img-blog.csdn.net/20180730183453770?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

从B 到 D 中顶点没有重复出现 ，所以是简单路径 ，边的数目是2，所以路径长度为 2。

![img](https://img-blog.csdn.net/20180730183453838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

图1和图2都是一个回路(环),图1中出了第一个顶点和最后一个顶点相同之外，其余顶点不相同，所以是简单环(简单回路)，图2，有与顶点C重复就不是一个简单环了；

**连通图相关术语**

**连通图**

在无向图G(V,{E})中，如果从顶点V到顶点W有路径，则称V和W是连通的。如果对于图中任意两个顶点Vi、Vj∈V,Vi和Vj都是连通的，则称G是连通图。

如下图所示：

![img](https://img-blog.csdn.net/20180730183453973?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

图1，顶点A到顶点E就无法连通，所以图1不是连通；图2，图3，图4属于连通图；

**连通分量**

若无向图为非连通图，则图中各个极大连通子图称作此图的连通分量；

图1是无向非连通图，由两个连通分量，分别是图2和图3。图4尽管也是图1的子图，但是它不满足极大连通，也就说极大连通应当是包含ABCD四个顶点，比如图2那样；

**强连通图**

在有向图G(V,{E})中，如果对于每一对Vi ,Vj∈V,Vi≠Vj,从Vi到Vj和从Vj到Vi都存在有向路径,则称G是强连通图。

![img](https://img-blog.csdn.net/20180730183453967?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

图1不是强连通图因为D到A不存在路径，图2属于强连通图。

**强连通分量**

若有向图不是强连通图，则图中各个极大强连通子图称作此图的强连通分量；

![img](https://img-blog.csdn.net/20180730183453996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

图1不是强连通图，但是图2是图1的强连通子图，也就是强连通分量；

**生成树和生成森林**

**生成树**

假设一个连通图有n个顶点和e条边，其中n-1条边和n个顶点构成一个极小连通子图，称该极小连通子图为此连通图的生成树；

![img](https://img-blog.csdn.net/20180730183454128?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

图1是一个连通图含有4个顶点和4条边，图2，图3，图4含有3条边和4个顶点，构成了一个极小连通图子图，也称为**生成树**，为什么是极小连通子图，因为图2，图3，图4中少一条边都构不成一个连通图，多一条边就变成一个回路(环)，所以是3条边和4个顶点构成的极小连通子图。图5尽管也是3个边4个顶点，但不是连通图。

**生成森林**

如果一个有向图恰有一个顶点的入度为0，其余顶点的入度为1，则是一颗**有向树**；

入度为0，相当于根节点，入度为1，相当于分支节点；，比如下面的有向图就是一个有向树

![img](https://img-blog.csdn.net/20180730183454104?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

顶点B的入度是0，其余顶点的入度是1；

一个有向图的**生成森林**由若干颗有向树组成，含有图中全部顶点，但有足以构成若干颗不相交的有向树的弧；

![img](https://img-blog.csdn.net/20180730183454294?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

有向图1去掉一些弧后分解成2颗有向树，图2和图3，这两颗树就是有向图图1的生成森林；

**2.图的存储结构**

1).邻接矩阵(数组)表示法

① 建立一个顶点表和一个邻接矩阵

② 设图 A = (V, E) 有 n 个顶点，则图的邻接矩阵是一个二维数组 A.Edge[n][n]。

注：在有向图的邻接矩阵中，

  第i行含义：以结点vi为尾的弧(即出度边）；

  第i列含义：以结点vi为头的弧(即入度边）。

邻接矩阵法优点：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、找顶点的邻接点等等。

邻接矩阵法缺点：n个顶点需要n*n个单元存储边(弧);空间效率为O(n^2)。

![img](https://img-blog.csdn.net/20180730183507825?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2).邻接表(链式)表示法

① 对每个顶点vi 建立一个单链表，把与vi有关联的边的信息（即度或出度边）链接起来，表中每个结点都设为3个域:

![img](https://img-blog.csdn.net/20180730183454546?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

② 每个单链表还应当附设一个头结点（设为2个域），存vi信息；

③ 每个单链表的头结点另外用顺序存储结构存储。

邻接表的优点：空间效率高；容易寻找顶点的邻接点；

邻接表的缺点：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。

3.图的遍历

遍历定义：从已给的连通图中某一顶点出发，沿着一些边，访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算。

图的遍历算法求解图的连通性问题、拓扑排序和求关键路径等算法的基础。

**图常用的遍历：一、深度优先搜索；二、广度优先搜索** 

**深度优先搜索（遍历）步骤：(如下图)**

① 访问起始点 v;

② 若v的第1个邻接点没访问过，深度遍历此邻接点；

③ 若当前邻接点已访问过，再找v的第2个邻接点重新遍历。

基本思想：——仿树的先序遍历过程。

遍历结果：v1->v2->v4->v8->v5-v3->v6->v7

**广度优先搜索（遍历）步骤：**

① 在访问了起始点v之后，依次访问 v的邻接点；

② 然后再依次（顺序）访问这些点（下一层）中未被访问过的邻接点；

③ 直到所有顶点都被访问过为止。

![img](https://img-blog.csdn.net/20180730183502333?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

遍历结果：v1->v2->v3->v4->v5-v6->v7->v8

4.图的连通性问题

1）对无向图进行遍历时，对于连通图，仅需从图中任一顶点出发，进行深度优先搜索或广度优先搜索，便可访问到图中所有顶点。

2）最小生成树:在连通网的所有生成树中，所有边的代价和最小的生成树。

构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST性质（假设N=(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。

Kruskal算法特点：将边归并，适于求稀疏网的最小生成树。

Prime算法特点: 将顶点归并，与边数无关，适于稠密网。

**Prime算法构造最小生成树过程如下图：**

![img](https://img-blog.csdn.net/20180730183459114?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

**Kruskal算法构造最小生成树过程如下图：**

![img](https://img-blog.csdn.net/20180730183504228?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

5.有向无环图及其应用

有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。

1）拓扑排序

拓扑排序对应施工的流程图具有特别重要的作用，它可以决定哪些子工程必须要先执行，哪些子工程要在某些工程执行后才可以执行。

我们把顶点表示活动、边表示活动间先后关系的有向图称做顶点活动网(Activity On Vertex network)，简称AOV网。

一个AOV网应该是一个有向无环图，即不应该带有回路，因为若带有回路，则回路上的所有活动都无法进行（对于数据流来说就是死循环）。在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列(Topological order)，由AOV网构造拓扑序列的过程叫做拓扑排序(Topological sort)。AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称作它的拓扑序列。

拓扑排序的实现：

a.在有向图中选一个没有前驱的顶点并且输出

b.从图中删除该顶点和所有以它为尾的弧（白话就是：删除所有和它有关的边）

c.重复上述两步，直至所有顶点输出，或者当前图中不存在无前驱的顶点为止，后者代表我们的有向图是有环的，因此，也可以通过拓扑排序来判断一个图是否有环。

![img](https://img-blog.csdn.net/20180730183503267?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

2）关键路径

AOE-网是一个带权的有向无环图，其中，顶点表示事件，弧表示活动，权表示活动持续的时间。通常，AOE-网可用来估算工程的完成时间。

**关键路径**：在AOE网中，从始点到终点具有最大路径长度（该路径上的各个活动所持续的时间之和）的路径称为关键路径。

**关键活动**：关键路径上的活动称为关键活动。**关键活动：e[i]=l[i]的活动**

由于AOE网中的某些活动能够同时进行，故完成整个工程所必须花费的时间应该为始点到终点的最大路径长度。关键路径长度是整个工程所需的最短工期。

**与关键活动有关的量**：

(1)事件的最早发生时间ve[k]：ve[k]是指从始点开始到顶点*vk*的最大路径长度。这个长度决定了所有从顶点*vk*发出的活动能够开工的最早时间。 

(2)事件的最迟发生时间vl[k]：vl[k]是指在不推迟整个工期的前提下,事件*vk*允许的最晚发生时间。

(3)活动的最早开始时间e[i]:若活动*ai*是由弧<*vk* , *vj*>表示，则活动*ai*的最早开始时间应等于事件*vk*的最早发生时间。因此，有：e[i]=ve[k]

(4)活动的最晚开始时间l[i]:活动*ai*的最晚开始时间是指，在不推迟整个工期的前提下， *ai*必须开始的最晚时间。若*ai*由弧<*vk*，*vj*>表示，则*ai*的最晚开始时间要保证事件*vj*的最迟发生时间不拖后。因此，有：l[i]=vl[j]-len<*vk*,*vj*> 

示例如下：

![img](https://img-blog.csdn.net/20180730183501952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![img](https://img-blog.csdn.net/20180730183503390?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

6.最短路径

从某顶点出发，沿图的边到达另一顶点所经过的*路径*中，各边上权值之和最小的一条*路径*叫做*最短路径。*

1）迪杰斯塔拉算法--单源最短路径

![img](https://img-blog.csdn.net/20180730183509396?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

 

![img](https://img-blog.csdn.net/20180730183514896?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTY4ODE0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

所有顶点间的最短路径—用Floyd（弗洛伊德）算法

## 6.ViewPager+Fragment实现多个子界面滑动

## 一、设计目标

最近做了一个智能机器人的控制APP，因为涉及的功能比较多，因此采用了三个可以滑动的子界面，效果图如下：下面讲解一下怎么用ViewPager+Fragment实现此界面效果。
![在这里插入图片描述](https://img-blog.csdn.net/20180918101543985?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzMTk4NzU4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## 二、实现方法

#### 第一步

新建一个Layout布局，用来容纳三个子界面。这里面要引入viewPager组件，XML代码为：

```
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="0dp"
    android:paddingLeft="0dp"
    android:paddingRight="0dp"
    android:paddingTop="0dp"
    tools:context=".activity.MainActivity">

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:background="@color/colorAccent">

            <LinearLayout
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_gravity="center_vertical">


            </LinearLayout>

            <LinearLayout
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_weight="1">

                <TextView
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:text="AFRobot"
                    android:id="@+id/textView_topTitle"
                    android:textSize="18dp"
                    android:layout_gravity="center_vertical"
                    android:textAlignment="center" />
            </LinearLayout>

            <LinearLayout
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_weight="1">

                <LinearLayout
                    android:orientation="horizontal"
                    android:layout_width="match_parent"
                    android:layout_height="match_parent"
                    android:layout_weight="1"></LinearLayout>


            </LinearLayout>

        </LinearLayout>
        <android.support.v4.view.ViewPager
            android:id="@+id/myViewPager"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:layout_marginLeft="0dp">
            <FrameLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:id="@+id/content"></FrameLayout>
        </android.support.v4.view.ViewPager>
        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="40dp"
            android:layout_gravity="bottom"
            android:background="@color/colorAccent">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="手动控制"
                android:id="@+id/textView_control"
                android:layout_gravity="center"
                android:layout_weight="1"
                android:textSize="16dp"
                android:layout_marginLeft="10dp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="数据监视"
                android:id="@+id/textView_oversee"
                android:layout_gravity="center"
                android:layout_weight="1"
                android:textSize="16dp" />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="连接设备"
                android:id="@+id/textView_connectDevice"
                android:layout_gravity="center"
                android:textSize="16dp"
                android:layout_marginRight="10dp" />
        </LinearLayout>

    </LinearLayout>
</RelativeLayout>

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115
```

#### 第二步

接下来新建三个子界面：
Fragment1：

```
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="手动控制"
        android:id="@+id/textView2"
        android:textSize="18dp" />
</LinearLayout>

12345678910111213
```

编写 Fragment_Control 类，继承Fragment，用来加载该界面：

```
package com.example.dx.testviewpager;

import android.os.Bundle;
import android.support.v4.app.Fragment;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;

/**
 * Created by dx on 2018/9/8.
 */
public class Fragment_Control extends Fragment {

    public View onCreateView(LayoutInflater inflater , ViewGroup container, Bundle savedInstanceState){
        View view=inflater .inflate(R.layout .activity_control ,container,false) ;

        return view;
    }

}

123456789101112131415161718192021
```

Fragment2：

```
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="数据监视"
        android:id="@+id/textView3"
        android:textSize="18dp" />
</LinearLayout>

12345678910111213
```

编写 Fragment_Oversee类，继承Fragment，用来加载该界面：

```
package com.example.dx.testviewpager;


import android.os.Bundle;
import android.support.v4.app.Fragment;

import android.view.LayoutInflater;

import android.view.View;
import android.view.ViewGroup;

/**
 * Created by dx on 2018/9/8.
 */
public class Fragment_Oversee  extends Fragment  {

    public View onCreateView(LayoutInflater inflater , ViewGroup container, Bundle savedInstanceState){
        View view=inflater .inflate(R.layout .activity_see ,container,false) ;

        return view;
    }



}

1234567891011121314151617181920212223242526
```

Fragment3：

```
    <?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="连接设备"
        android:id="@+id/textView"
        android:textSize="18dp" />
</LinearLayout>

1234567891011121314
```

编写 Fragment_ConnectDevice类，继承Fragment，用来加载该界面：

```
package com.example.dx.testviewpager;


import android.os.Bundle;
import android.support.v4.app.Fragment;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;



/**
 * Created by dx on 2018/9/10.
 */
public class Fragment_ConnectDevice extends Fragment {


    public View onCreateView(LayoutInflater inflater , ViewGroup container, Bundle savedInstanceState){
        View view=inflater .inflate(R.layout .activity_connect  ,container,false) ;

        return view;
    }
}

12345678910111213141516171819202122232425
```

#### 第三步

编写TabFragmentPagerAdapter类，继承FragmentPagerAdapter类：

```
package com.example.dx.testviewpager;

import android.support.v4.app.Fragment;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentPagerAdapter;
import android.view.ViewGroup;

import java.util.List;

/**
 * Created by dx on 2018/9/18.
 */
public class TabFragmentPagerAdapter extends FragmentPagerAdapter {
    private FragmentManager mfragmentManager;
    private List<Fragment> mlist;


    public TabFragmentPagerAdapter(FragmentManager fm, List<Fragment> list) {
        super(fm);
        this.mlist = list;
    }

    @Override
    public void setPrimaryItem(ViewGroup container, int position, Object object) {
        super.setPrimaryItem(container, position, object);
    }

    @Override
    public Fragment getItem(int arg0) {
        return mlist.get(arg0);//显示第几个页面
    }

    @Override
    public int getCount() {
        return mlist.size();//有几个页面
    }
}

1234567891011121314151617181920212223242526272829303132333435363738
```

#### 第四步

MainActivity代码为：

```
package com.example.dx.testviewpager;

import android.graphics.Color;
import android.support.v4.app.Fragment;
import android.support.v4.view.ViewPager;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.List;

public class MainActivity extends AppCompatActivity {
    private List<Fragment> list;
    private ViewPager myViewPager;
    private TabFragmentPagerAdapter adapter;

    private TextView  text_Control;
    private TextView  text_Oversee;
    private TextView  text_connectDevice;
    private TextView  topTitle;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initView();
    }
    private void initView()
    {
        text_Control=(TextView)  findViewById(R.id.textView_control ) ;
        text_Oversee =(TextView)  findViewById(R.id.textView_oversee ) ;
        text_connectDevice =(TextView)  findViewById(R.id.textView_connectDevice  ) ;
        topTitle =(TextView)  findViewById(R.id.textView_topTitle ) ;

        myViewPager = (ViewPager) findViewById(R.id.myViewPager);
        //绑定点击事件
        myViewPager.setOnPageChangeListener(new MyPagerChangeListener()) ;
        //把Fragment添加到List集合里面
        list = new ArrayList<>();
        list.add(new Fragment_Control() );
        list.add(new Fragment_Oversee() );
        list.add(new Fragment_ConnectDevice() );
        adapter = new TabFragmentPagerAdapter(getSupportFragmentManager(), list);
        myViewPager.setAdapter(adapter);
        myViewPager.setCurrentItem(1);  //初始化显示第一个页面

    }

    /**
     * 设置一个ViewPager的侦听事件，当左右滑动ViewPager时菜单栏被选中状态跟着改变
     *
     */
    public class MyPagerChangeListener implements ViewPager.OnPageChangeListener {

        @Override
        public void onPageScrollStateChanged(int arg0) {
        }

        @Override
        public void onPageScrolled(int arg0, float arg1, int arg2) {
        }

        @Override
        public void onPageSelected(int arg0) {
            switch (arg0) {//状态改变时底部对应的字体颜色改变
                case 0:
                    text_Control  .setTextColor(Color.GREEN  );
                    text_Oversee  .setTextColor(Color.BLACK );
                    text_connectDevice   .setTextColor(Color.BLACK );
                    topTitle .setText("手动控制") ;
                    break;
                case 1:
                    text_Control .setTextColor(Color.BLACK );
                    text_Oversee .setTextColor(Color.GREEN );
                    text_connectDevice  .setTextColor(Color.BLACK );
                    topTitle .setText("数据监控") ;
                    break;
                case 2:
                    text_Control .setTextColor(Color.BLACK );
                    text_Oversee .setTextColor(Color.BLACK  );
                    text_connectDevice  .setTextColor(Color.GREEN );
                    topTitle .setText("连接设备") ;
                    break;
            }

        }

    }

}
```

